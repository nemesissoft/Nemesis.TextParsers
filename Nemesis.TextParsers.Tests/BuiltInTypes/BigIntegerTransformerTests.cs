using Nemesis.TextParsers.Parsers;

namespace Nemesis.TextParsers.Tests.BuiltInTypes;

[TestFixture]
public class BigIntegerTransformerTests
{
    private static readonly NumberTransformer<BigInteger> _sut = NumberTransformerCache.GetNumberHandler<BigInteger>();

    [Test]
    public void Zero_ShouldBeLessThanOne() => Assert.That(_sut.Zero, Is.LessThan(_sut.One));

    [Test]
    public void AddShouldBePossibleToGetToNextValue()
    {
        var actual = _sut.Add(_sut.FromInt64(100), _sut.One);

        Assert.That(actual, Is.EqualTo(_sut.FromInt64(101)));
    }


    [Test]
    public void TryParseTest()
    {
        BigInteger one = _sut.One, ten = _sut.FromInt64(10), two = _sut.FromInt64(2);
        BigInteger expectedPositive = _sut.One, expectedNegative = _sut.Sub(_sut.Zero, two);

        string textPositive = "1", textNegative = "-2";
        for (var i = 0; i < 50; i++)
        {
            bool successPositive = _sut.TryParse(textPositive.AsSpan(), out var valuePositive);
            bool successNegative = _sut.TryParse(textNegative.AsSpan(), out var valueNegative);
            Assert.Multiple(() =>
            {
                Assert.That(successPositive, Is.True, $"Failed at '{textPositive}'");
                Assert.That(valuePositive, Is.EqualTo(expectedPositive));

                Assert.That(successNegative, Is.True, $"Failed at '{textNegative}'");
                Assert.That(valueNegative, Is.EqualTo(expectedNegative));
            });
            expectedPositive = _sut.Add(_sut.Mul(expectedPositive, ten), one);
            textPositive += "1";

            expectedNegative = _sut.Sub(_sut.Mul(expectedNegative, ten), two);
            textNegative += "2";
        }
    }

    [Test]
    public void Shr_DividesByTwo_OnEveryPass()
    {
        BigInteger curr = BigInteger.Parse("2535301200456458802993406410752");

        var expectedNumbersText = "2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976,2305843009213693952,4611686018427387904,9223372036854775808,18446744073709551616,36893488147419103232,73786976294838206464,147573952589676412928,295147905179352825856,590295810358705651712,1180591620717411303424,2361183241434822606848,4722366482869645213696,9444732965739290427392,18889465931478580854784,37778931862957161709568,75557863725914323419136,151115727451828646838272,302231454903657293676544,604462909807314587353088,1208925819614629174706176,2417851639229258349412352,4835703278458516698824704,9671406556917033397649408,19342813113834066795298816,38685626227668133590597632,77371252455336267181195264,154742504910672534362390528,309485009821345068724781056,618970019642690137449562112,1237940039285380274899124224,2475880078570760549798248448,4951760157141521099596496896,9903520314283042199192993792,19807040628566084398385987584,39614081257132168796771975168,79228162514264337593543950336,158456325028528675187087900672,316912650057057350374175801344,633825300114114700748351602688,1267650600228229401496703205376";

        IReadOnlyList<string> expectedNumbers = expectedNumbersText.Split(',').Reverse().ToList();

        for (byte i = 0; i < expectedNumbers.Count; i++)
        {
            var expected = curr / 2;
            curr = _sut.ShR(curr, 1);

            Assert.Multiple(() =>
            {
                var expectedFromList = BigInteger.Parse(expectedNumbers[i]);
                var error = $"[{i}]={expectedFromList} ; {expected} != {curr}";

                Assert.That(curr, Is.EqualTo(expected), error);

                Assert.That(curr, Is.EqualTo(expectedFromList), error);
            });
        }
    }

    [Test]
    public void Shl_MultipliesByTwo_OnEveryPass()
    {
        BigInteger curr = 1;

        var expectedNumbersText = "2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824,2147483648,4294967296,8589934592,17179869184,34359738368,68719476736,137438953472,274877906944,549755813888,1099511627776,2199023255552,4398046511104,8796093022208,17592186044416,35184372088832,70368744177664,140737488355328,281474976710656,562949953421312,1125899906842624,2251799813685248,4503599627370496,9007199254740992,18014398509481984,36028797018963968,72057594037927936,144115188075855872,288230376151711744,576460752303423488,1152921504606846976,2305843009213693952,4611686018427387904,9223372036854775808,18446744073709551616,36893488147419103232,73786976294838206464,147573952589676412928,295147905179352825856,590295810358705651712,1180591620717411303424,2361183241434822606848,4722366482869645213696,9444732965739290427392,18889465931478580854784,37778931862957161709568,75557863725914323419136,151115727451828646838272,302231454903657293676544,604462909807314587353088,1208925819614629174706176,2417851639229258349412352,4835703278458516698824704,9671406556917033397649408,19342813113834066795298816,38685626227668133590597632,77371252455336267181195264,154742504910672534362390528,309485009821345068724781056,618970019642690137449562112,1237940039285380274899124224,2475880078570760549798248448,4951760157141521099596496896,9903520314283042199192993792,19807040628566084398385987584,39614081257132168796771975168,79228162514264337593543950336,158456325028528675187087900672,316912650057057350374175801344,633825300114114700748351602688,1267650600228229401496703205376";

        IReadOnlyList<string> expectedNumbers = expectedNumbersText.Split(',');

        for (byte i = 0; i < expectedNumbers.Count; i++)
        {
            var expected = curr * 2;
            curr = _sut.ShL(curr, 1);

            Assert.Multiple(() =>
            {
                var expectedFromList = BigInteger.Parse(expectedNumbers[i]);
                var error = $"[{i}]={expectedFromList} ; {expected} != {curr}";

                Assert.That(curr, Is.EqualTo(expected), error);
                Assert.That(curr, Is.EqualTo(expectedFromList), error);
            });
        }
    }
}