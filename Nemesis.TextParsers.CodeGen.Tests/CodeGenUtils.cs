#nullable enable
extern alias original;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Nemesis.TextParsers.CodeGen.Utils;

namespace Nemesis.TextParsers.CodeGen.Tests;

internal static class CodeGenUtils
{
    public static Compilation CreateValidCompilation(string source, [CallerMemberName] string? memberName = null) =>
        CreateTestCompilation(source, [typeof(original::Nemesis.TextParsers.ITransformer).GetTypeInfo().Assembly], memberName);

    public static Compilation CreateTestCompilation(string source, Assembly[]? additionalAssemblies = null, [CallerMemberName] string? memberName = null)
    {
        var assemblyPath = Path.GetDirectoryName(typeof(object).Assembly.Location) ?? throw new InvalidOperationException("The location of the .NET assemblies cannot be retrieved");

        static SyntaxTree Parse(string source) =>
            CSharpSyntaxTree
            .ParseText(source, CSharpParseOptions.Default.WithLanguageVersion(LanguageVersion.Latest));

        SyntaxTree[] trees =
        [
            Parse(source)
#if !NET
            ,
            Parse("""
                namespace System.Runtime.CompilerServices
                {
                    [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
                    internal static class IsExternalInit { }
                }

                """)
#endif
        ];

        var references = new List<PortableExecutableReference>(8);
        void AddRef(string path) =>
            references.Add(MetadataReference.CreateFromFile(path));

        foreach (var t in new[] { typeof(Binder), typeof(BigInteger) })
            AddRef(t.GetTypeInfo().Assembly.Location);

        if (additionalAssemblies is not null)
            foreach (var ass in additionalAssemblies)
                AddRef(ass.Location);
#if NET
        AddRef(Path.Combine(assemblyPath, "System.Runtime.dll"));
#else
        var standardAssembly = AppDomain.CurrentDomain.GetAssemblies()
            .FirstOrDefault(a => a.GetName().Name == "netstandard");

        AddRef(standardAssembly?.Location
               ?? throw new NotSupportedException("netstandard is needed for legacy framework tests")
        );

        AddRef(typeof(System.ComponentModel.EditorBrowsableAttribute).GetTypeInfo().Assembly.Location);
#endif

        return CSharpCompilation.Create($"{memberName}_Compilation", trees,
            references, new(OutputKind.DynamicallyLinkedLibrary));
    }


    private static readonly Regex _headerPattern = new(@"/\*\s*<auto-generated>   .+?   </auto-generated>\s*\*/", RegexOptions.Singleline | RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);
    private static readonly Regex _generatorPattern = new(@""".*Generator""\s*,\s*""([0-9.]+)""", RegexOptions.IgnoreCase | RegexOptions.CultureInvariant | RegexOptions.IgnorePatternWhitespace | RegexOptions.Compiled);

    public static string ScrubGeneratorComments(string text)
    {
        text = _generatorPattern.Replace(text, "string.Empty, string.Empty");
        text = _headerPattern.Replace(text, "//HEAD");
        return text;
    }

    public static IReadOnlyList<string> GetGeneratedTreesOnly(Compilation compilation, ISourceGenerator sourceGenerator, string attributeName, int requiredCardinality = 1)
    {
        GeneratorDriver driver = CSharpGeneratorDriver.Create(
            generators: new ISourceGenerator[] { sourceGenerator },
            parseOptions: (CSharpParseOptions)compilation.SyntaxTrees.First().Options,
            driverOptions: new GeneratorDriverOptions(default, trackIncrementalGeneratorSteps: true));

        driver.RunGeneratorsAndUpdateCompilation(compilation, out var newCompilation, out var diagnostics);

        Assert.That(diagnostics, Is.Empty);

        SyntaxTree? attributeTree = null;
        foreach (var tree in newCompilation.SyntaxTrees)
        {
            var attributeDeclaration = tree.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>()
                .FirstOrDefault(cds => string.Equals(cds.Identifier.ValueText, attributeName, StringComparison.Ordinal));
            if (attributeDeclaration != null)
            {
                attributeTree = tree;
                break;
            }
        }
        Assert.That(attributeTree, Is.Not.Null, "Auto attribute not found among generated trees");

        var toRemove = compilation.SyntaxTrees.Append(attributeTree!);

        var generatedTrees = newCompilation.RemoveSyntaxTrees(toRemove).SyntaxTrees.ToList();
        Assert.That(generatedTrees, Has.Count.EqualTo(requiredCardinality));

        return generatedTrees.Select(tree =>
            ((CompilationUnitSyntax)tree.GetRoot())
            .ToFullString()).ToList();
    }



    public static GeneratorRunResult RunIncrementalGenerator(Compilation compilation, IIncrementalGenerator sourceGenerator)
    {
        GeneratorDriver driver = CSharpGeneratorDriver.Create(
            generators: new ISourceGenerator[] { sourceGenerator.AsSourceGenerator() },
            parseOptions: (CSharpParseOptions)compilation.SyntaxTrees.First().Options,
            driverOptions: new GeneratorDriverOptions(default, trackIncrementalGeneratorSteps: true));

        driver = driver.RunGenerators(compilation);
        return driver.GetRunResult().Results.Single();
    }

    public static IReadOnlyList<string> RunIncrementalGeneratorAndGetGeneratedSources(Compilation compilation, IIncrementalGenerator sourceGenerator, string attributeNameToRemove, int requiredCardinality = 1)
    {
        var result = RunIncrementalGenerator(compilation, sourceGenerator);
        return GetGeneratedOutput(attributeNameToRemove, requiredCardinality, result);
    }

    public static (IReadOnlyList<string> Sources, IReadOnlyList<TMeta> Meta) RunIncrementalGeneratorAndCaptureInputs<TMeta>(Compilation compilation, IIncrementalGenerator sourceGenerator, string attributeNameToRemove, int requiredCardinality = 1)
          where TMeta : struct
    {
        var result = RunIncrementalGenerator(compilation, sourceGenerator);
        var generatedSources = GetGeneratedOutput(attributeNameToRemove, requiredCardinality, result);

        IReadOnlyList<TMeta> meta = [];
        if (result.TrackedSteps.TryGetValue("Meta", out var metaValue))
        {
            var stepResults = metaValue.Single().Outputs
                .Select(o => (
                    Result: (Result<TMeta?, Diagnostic>)o.Value,
                    o.Reason
                ))
                .ToList();

            Assert.Multiple(() =>
            {
                Assert.That(stepResults.Select(o => o.Reason), Has.All.EqualTo(IncrementalStepRunReason.New));
                Assert.That(stepResults.Select(o => o.Result.IsSuccess && o.Result.Value is not null), Has.All.EqualTo(true));
            });

            meta = stepResults.Select(s => s.Result.Value!.Value!).ToList();
        }

        return (generatedSources, meta);
    }

    private static IReadOnlyList<string> GetGeneratedOutput(string attributeNameToRemove, int requiredCardinality, GeneratorRunResult result)
    {
        Assert.Multiple(() =>
        {
            Assert.That(result.Diagnostics, Is.Empty);
            Assert.That(result.Exception, Is.Null);
            Assert.That(result.GeneratedSources, Has.Length.GreaterThan(1));
        });

        var generatedSources = result.GeneratedSources
            .Where(gen => !gen.HintName.Equals($"{attributeNameToRemove}.g.cs"))
            .Select(gen => gen.SourceText.ToString())
            .ToList();
        Assert.That(generatedSources, Has.Count.EqualTo(requiredCardinality));
        return generatedSources;
    }

    public static string NormalizeNewLine(string text) => text.Replace("\r\n", "\n").Replace("\r", "\n");
}


internal class IgnoreNewLinesComparer : IComparer<string>, IEqualityComparer<string>
{
    public static readonly IComparer<string> Comparer = new IgnoreNewLinesComparer();

    public static readonly IEqualityComparer<string> EqualityComparer = new IgnoreNewLinesComparer();

    public int Compare(string? x, string? y) => string.CompareOrdinal(NormalizeNewLines(x), NormalizeNewLines(y));

    public bool Equals(string? x, string? y) => NormalizeNewLines(x) == NormalizeNewLines(y);

    public int GetHashCode(string s) => NormalizeNewLines(s)?.GetHashCode() ?? 0;

    public static string? NormalizeNewLines(string? s) => s?
        .Replace(Environment.NewLine, "")
        .Replace("\n", "")
        .Replace("\r", "");
}
