using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

using Microsoft.CodeAnalysis;


#nullable enable

namespace Nemesis.TextParsers.CodeGen.Deconstructable
{
    public partial class AutoDeconstructableGenerator
    {
        private static string RenderRecord(INamedTypeSymbol typeSymbol, string typeModifiers, IReadOnlyList<(string Name, string Type)> members, GeneratedDeconstructableSettings? settings, IEnumerable<string> namespaces)
        {
            string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();

            var source = new StringBuilder(512);
            source.AppendLine(@"/* <auto-generated>
     This code was generated by a tool. Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 </auto-generated> */");

            static (string Namespace, string Name, bool IsStatic, string? Alias) GetNamespaceMeta(string ns)
            {
                ns = ns.Trim();
                if (ns.StartsWith("static", StringComparison.Ordinal))
                    return (ns, ns.Substring(6).Trim(), true, null);
                else if (ns.IndexOf('=') is { } i && i > -1 && ns.Length > i)
                    return (ns, ns.Substring(i + 1).Trim(), false, ns.Substring(0, i).Trim());
                else
                    return (ns, ns, false, null);
            }

            var sortedNamespaces = namespaces.Select(GetNamespaceMeta)
                    .OrderBy(x => x.IsStatic ? 1 : x.Alias == null ? 0 : 2)
                    .ThenBy(x => x.Alias?.ToString())
                    .ThenByDescending(x => x.Name.ToString().StartsWith("System"))
                    .ThenBy(x => x.Name.ToString())
                ;
            
            foreach (var (ns, _, _, _) in sortedNamespaces)
                if (!string.Equals(namespaceName, ns, StringComparison.Ordinal))
                    source.Append("using ").Append(ns).AppendLine(";");

            var typeName = typeSymbol.Name;

            source.Append($@"
namespace {namespaceName}
{{
    [Transformer(typeof({typeName}Transformer))]
    {typeModifiers} {typeName} 
    {{
#if DEBUG
        internal void DebuggerHook() {{ System.Diagnostics.Debugger.Launch(); }}
#endif
    }}

    [System.CodeDom.Compiler.GeneratedCode(""AutoDeconstructableGenerator"", ""{Assembly.GetExecutingAssembly().GetName().Version}"")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    sealed class {typeName}Transformer : TransformerBase<{typeName}>
    {{");

            foreach (var (name, type) in members)
                source.Append($@"
        private readonly ITransformer<{type}> {GetTransformerName(name)} = TextTransformer.Default.GetTransformer<{type}>();");
            source.AppendLine($@"
        private const int ARITY = {members.Count};").AppendLine();


            if (settings is { } s)
            {
                source.AppendLine($@"
        private readonly TupleHelper _helper = new TupleHelper({Escape(s.Delimiter)}, {Escape(s.NullElementMarker)}, {Escape(s.EscapingSequenceStart)}, {Escape(s.Start)}, {Escape(s.End)});");

                if (s.UseDeconstructableEmpty)
                {
                    source.Append($@"
        public override {typeName} GetEmpty() => new {typeName}(");

                    for (int i = 0; i < members.Count; i++)
                    {
                        source.Append($"{GetTransformerName(members[i].Name)}.GetEmpty()");
                        if (i < members.Count - 1)
                            source.Append(", ");
                    }
                    source.AppendLine(");");
                }
            }
            else
            {
                source.Append($@"
        private readonly TupleHelper _helper;

        public {typeName}Transformer(Nemesis.TextParsers.ITransformerStore transformerStore)
        {{");
                source.Append($@"
            _helper = transformerStore.SettingsStore.GetSettingsFor<Nemesis.TextParsers.Settings.DeconstructableSettings>().ToTupleHelper();");
                source.Append(@"
        }
");
                //IDEA: generate GetEmpty based on DeconstructableSettings taken from SettingsStore
            }

            RenderParseCore(source, typeName, members);
            source.AppendLine();
            RenderFormat(source, typeName, members);

            source.AppendLine("    }");
            source.Append("}");
            return source.ToString();

            static string Escape(char? c)
            {
                return c switch
                {
                    null => "null",
                    '\'' => GetEscapeCode(@"'"), // single quote, needed for character literals
                    '\"' => GetEscapeCode("\""), // double quote, needed for string literals
                    '\\' => GetEscapeCode(@"\"), // backslash
                    '\0' => GetEscapeCode(@"0"), // Unicode character 0
                    '\a' => GetEscapeCode(@"a"), // Alert (character 7)
                    '\b' => GetEscapeCode(@"b"), // Backspace (character 8)
                    '\f' => GetEscapeCode(@"f"), // Form feed (character 12)
                    '\n' => GetEscapeCode(@"n"), // New line (character 10)
                    '\r' => GetEscapeCode(@"r"), // Carriage return (character 13)
                    '\t' => GetEscapeCode(@"t"), // Horizontal tab (character 9)
                    '\v' => GetEscapeCode(@"v"), // Vertical tab (character 11)
                    _ => $"'{c}'"
                };
                static string GetEscapeCode(string ch) => $@"'\{ch}'";
            }
        }

        private static void RenderParseCore(StringBuilder source, string typeName, IReadOnlyList<(string Name, string Type)> members)
        {
            source.AppendLine($"        protected override {typeName} ParseCore(in ReadOnlySpan<char> input)");
            source.AppendLine("        {");
            source.AppendLine("            var enumerator = _helper.ParseStart(input, ARITY);");

            for (int i = 1; i <= members.Count; i++)
            {
                if (i != 1)
                    source.AppendLine($"            _helper.ParseNext(ref enumerator, {i});");
                source.AppendLine($"            var t{i} = _helper.ParseElement(ref enumerator, {GetTransformerName(members[i - 1].Name)});").AppendLine();
            }

            source.Append("            _helper.ParseEnd(ref enumerator, ARITY);").AppendLine();
            source.Append($"            return new {typeName}(");
            for (int i = 1; i <= members.Count; i++)
            {
                source.Append($"t{i}");
                if (i < members.Count)
                    source.Append(", ");
            }
            source.AppendLine(");");
            source.AppendLine("        }");
        }

        private static void RenderFormat(StringBuilder source, string typeName, IReadOnlyList<(string Name, string Type)> members)
        {
            source.AppendLine($"        public override string Format({typeName} element)");
            source.AppendLine("        {");
            source.AppendLine("            Span<char> initialBuffer = stackalloc char[32];");
            source.AppendLine("            var accumulator = new ValueSequenceBuilder<char>(initialBuffer);");
            source.AppendLine("            try");
            source.AppendLine("            {");
            source.AppendLine("                 _helper.StartFormat(ref accumulator);");

            source.Append("                 var (");
            for (int i = 0; i < members.Count; i++)
            {
                source.Append($"{members[i].Name}");
                if (i < members.Count - 1)
                    source.Append(", ");
            }
            source.AppendLine(") = element;");

            for (int i = 1; i <= members.Count; i++)
            {
                if (i != 1)
                    source.AppendLine("                _helper.AddDelimiter(ref accumulator);");
                source.AppendLine($"                _helper.FormatElement({GetTransformerName(members[i - 1].Name)}, {members[i - 1].Name}, ref accumulator);").AppendLine();
            }

            source.AppendLine("                _helper.EndFormat(ref accumulator);");
            source.AppendLine("                return accumulator.AsSpan().ToString();");
            source.AppendLine("            }");
            source.AppendLine("            finally { accumulator.Dispose(); }");
            source.AppendLine("        }");
        }

        private static string GetTransformerName(string memberName) => $"_transformer_{memberName}";
    }
}