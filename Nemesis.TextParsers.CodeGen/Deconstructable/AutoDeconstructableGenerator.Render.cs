#nullable enable

namespace Nemesis.TextParsers.CodeGen.Deconstructable;

public partial class AutoDeconstructableGenerator
{
    private static string RenderRecord(INamedTypeSymbol typeSymbol, string typeModifiers, IReadOnlyList<(string Name, string Type)> members, GeneratedDeconstructableSettings? settings, IEnumerable<string> namespaces)
    {
        string namespaceName = typeSymbol.ContainingNamespace.ToDisplayString();

        var source = new StringBuilder(512);
        source.AppendLine(@"/* <auto-generated>
     This code was generated by a tool. Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
 </auto-generated> */");

        static (string Namespace, string Name, bool IsStatic, string? Alias) GetNamespaceMeta(string ns)
        {
            ns = ns.Trim();
            if (ns.StartsWith("static", StringComparison.Ordinal))
                return (ns, ns.Substring(6).Trim(), true, null);
            else if (ns.IndexOf('=') is { } i && i > -1 && ns.Length > i)
                return (ns, ns.Substring(i + 1).Trim(), false, ns.Substring(0, i).Trim());
            else
                return (ns, ns, false, null);
        }

        var sortedNamespaces = namespaces.Select(GetNamespaceMeta)
                .OrderBy(x => x.IsStatic ? 1 : x.Alias == null ? 0 : 2)
                .ThenBy(x => x.Alias?.ToString())
                .ThenByDescending(x => x.Name.ToString().StartsWith("System"))
                .ThenBy(x => x.Name.ToString())
            ;

        foreach (var (ns, _, _, _) in sortedNamespaces)
            if (!string.Equals(namespaceName, ns, StringComparison.Ordinal))
                source.Append("using ").Append(ns).AppendLine(";");

        var typeName = typeSymbol.Name;

        source.Append($@"
namespace {namespaceName}
{{
    [Transformer(typeof({typeName}Transformer))]
    {typeModifiers} {typeName} 
    {{
#if DEBUG
#pragma warning disable CS0108 // Member hides inherited member; missing new keyword
        internal void DebuggerHook() {{ System.Diagnostics.Debugger.Launch(); }}
#pragma warning restore CS0108 // Member hides inherited member; missing new keyword
#endif
    }}

    [System.CodeDom.Compiler.GeneratedCode(""AutoDeconstructableGenerator"", ""{Assembly.GetExecutingAssembly().GetName().Version}"")]
    [System.Runtime.CompilerServices.CompilerGenerated]
    sealed class {typeName}Transformer : TransformerBase<{typeName}>
    {{");

        foreach (var (name, type) in members)
            source.Append($@"
        private readonly ITransformer<{type}> {GetTransformerName(name)};");
        source.AppendLine($@"
        private const int ARITY = {members.Count};");


        source.Append($@"
        public {typeName}Transformer(ITransformerStore store)
        {{");

        foreach (var (name, type) in members)
            source.Append($@"
            {GetTransformerName(name)} = store.GetTransformer<{type}>();");

        source.AppendLine(@"        
        }");


        if (settings is { } s)
        {
            source.AppendLine($@"
        private readonly TupleHelper _helper = new TupleHelper({Escape(s.Delimiter)}, {Escape(s.NullElementMarker)}, {Escape(s.EscapingSequenceStart)}, {Escape(s.Start)}, {Escape(s.End)});");

            if (s.UseDeconstructableEmpty)
            {
                source.Append($@"
        public override {typeName} GetEmpty() => new {typeName}(");

                for (int i = 0; i < members.Count; i++)
                {
                    source.Append($"{GetTransformerName(members[i].Name)}.GetEmpty()");
                    if (i < members.Count - 1)
                        source.Append(", ");
                }
                source.AppendLine(");");
            }
        }
        else
        {
            source.Append($@"
        private readonly TupleHelper _helper;

        public {typeName}Transformer(Nemesis.TextParsers.ITransformerStore transformerStore)
        {{");
            source.Append($@"
            _helper = transformerStore.SettingsStore.GetSettingsFor<Nemesis.TextParsers.Settings.DeconstructableSettings>().ToTupleHelper();");
            source.Append(@"
        }
");
            //IDEA: generate GetEmpty based on DeconstructableSettings taken from SettingsStore
        }

        RenderParseCore(source, typeName, members);
        source.AppendLine();
        RenderFormat(source, typeName, members);

        source.AppendLine("    }");
        source.Append("}");
        return source.ToString();

        static string Escape(char? c)
        {
            return c switch
            {
                null => "null",
                '\'' => GetEscapeCode(@"'"), // single quote, needed for character literals
                '\"' => GetEscapeCode("\""), // double quote, needed for string literals
                '\\' => GetEscapeCode(@"\"), // backslash
                '\0' => GetEscapeCode(@"0"), // Unicode character 0
                '\a' => GetEscapeCode(@"a"), // Alert (character 7)
                '\b' => GetEscapeCode(@"b"), // Backspace (character 8)
                '\f' => GetEscapeCode(@"f"), // Form feed (character 12)
                '\n' => GetEscapeCode(@"n"), // New line (character 10)
                '\r' => GetEscapeCode(@"r"), // Carriage return (character 13)
                '\t' => GetEscapeCode(@"t"), // Horizontal tab (character 9)
                '\v' => GetEscapeCode(@"v"), // Vertical tab (character 11)
                _ => $"'{c}'"
            };
            static string GetEscapeCode(string ch) => $@"'\{ch}'";
        }
    }

    private static void RenderParseCore(StringBuilder source, string typeName, IReadOnlyList<(string Name, string Type)> members)
    {
        source.AppendLine($"        protected override {typeName} ParseCore(in ReadOnlySpan<char> input)");
        source.AppendLine("        {");
        source.AppendLine("            var enumerator = _helper.ParseStart(input, ARITY);");

        for (int i = 1; i <= members.Count; i++)
        {
            var index = i != 1 ? $", {i}" : "";
            source.AppendLine($"            var t{i} = _helper.ParseElement(ref enumerator, {GetTransformerName(members[i - 1].Name)}{index});")
                  .AppendLine();
        }

        source.Append("            _helper.ParseEnd(ref enumerator, ARITY);").AppendLine();
        source.Append($"            return new {typeName}(");
        for (int i = 1; i <= members.Count; i++)
        {
            source.Append($"t{i}");
            if (i < members.Count)
                source.Append(", ");
        }
        source.AppendLine(");");
        source.AppendLine("        }");
    }

    private static void RenderFormat(StringBuilder source, string typeName, IReadOnlyList<(string Name, string Type)> members)
    {
        source.AppendLine($"        public override string Format({typeName} element)");
        source.AppendLine("        {");
        source.AppendLine("            Span<char> initialBuffer = stackalloc char[32];");
        source.AppendLine("            var accumulator = new ValueSequenceBuilder<char>(initialBuffer);");
        source.AppendLine("            try");
        source.AppendLine("            {");
        source.AppendLine("                 _helper.StartFormat(ref accumulator);");

        //Deconstruct
        if (members.Count == 1)
        {
            var member = members[0];
            source.AppendLine($"                 {member.Type} {member.Name};");
            source.AppendLine($"                 element.Deconstruct(out {member.Name});").AppendLine();
        }
        else
        {
            source.Append("                 var (");
            for (int i = 0; i < members.Count; i++)
            {
                source.Append($"{members[i].Name}");
                if (i < members.Count - 1)
                    source.Append(", ");
            }
            source.AppendLine(") = element;");
        }


        for (int i = 1; i <= members.Count; i++)
        {
            if (i != 1)
                source.AppendLine("                _helper.AddDelimiter(ref accumulator);");
            source.AppendLine($"                _helper.FormatElement({GetTransformerName(members[i - 1].Name)}, {members[i - 1].Name}, ref accumulator);").AppendLine();
        }

        source.AppendLine("                _helper.EndFormat(ref accumulator);");
        source.AppendLine("                return accumulator.AsSpan().ToString();");
        source.AppendLine("            }");
        source.AppendLine("            finally { accumulator.Dispose(); }");
        source.AppendLine("        }");
    }

    private static string GetTransformerName(string memberName) => $"_transformer_{memberName}";
}