#nullable enable
using Nemesis.TextParsers.CodeGen.Utils;

namespace Nemesis.TextParsers.CodeGen.Enums;

partial class EnumTransformerGenerator
{
    private static DiagnosticDescriptor GetDiagnosticDescriptor(byte id, string message, DiagnosticSeverity diagnosticSeverity = DiagnosticSeverity.Error) =>
        new($"{nameof(EnumTransformerGenerator)}{id:00}", "Couldn't generate automatic EnumTransformer",
            "{0}.{1}: " + message, nameof(EnumTransformerGenerator), diagnosticSeverity, true);

    internal static readonly DiagnosticDescriptor CaseInsensitiveIncompatibleMemberNames = GetDiagnosticDescriptor(1, $"When {ATTRIBUTE_NAME}.{PROPERTY_CASE_INSENSITIVE} is set to true, enum members must be distinguishable");

    private const string HEADER = $"""
        /* <auto-generated>
             This code was generated by {nameof(EnumTransformerGenerator)}. Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
         </auto-generated> */

        """;

    private static readonly string CODE_GEN_ATTRIBUTES = $"""
        [System.CodeDom.Compiler.GeneratedCode("{nameof(EnumTransformerGenerator)}", "{Assembly.GetExecutingAssembly().GetName().Version}")]
        [System.Runtime.CompilerServices.CompilerGenerated]
        """;

    internal const string ATTRIBUTE_NAME = "AutoEnumTransformerAttribute";

    protected override string GetAttributeName() => ATTRIBUTE_NAME;

    private const string ATTRIBUTE_FULL_NAME = $"Auto.{ATTRIBUTE_NAME}";

    private const string PROPERTY_CASE_INSENSITIVE = $"CaseInsensitive";
    private const string PROPERTY_ALLOW_PARSING_NUMERICS = $"AllowParsingNumerics";
    private const string PROPERTY_TRANSFORMER_CLASS_NAME = $"TransformerClassName";
    private const string PROPERTY_TRANSFORMER_CLASS_NAMESPACE = $"TransformerClassNamespace";

    private const string ATTRIBUTE_SOURCE = $$"""
     #nullable enable
     
     namespace Auto
     {
         [global::System.AttributeUsage(global::System.AttributeTargets.Enum)]
     #if NET5_0_OR_GREATER
         [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage(Justification = "Generated by the source generator.")]
     #else
         [global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
     #endif
         internal sealed class {{ATTRIBUTE_NAME}} : global::System.Attribute
         {
             public bool {{PROPERTY_CASE_INSENSITIVE}} { get; set; } = true;
             public bool {{PROPERTY_ALLOW_PARSING_NUMERICS}} { get; set; } = true;
     
             /// <summary>
             /// The name to use for the transformer class. If not provided, the enum name with "Transformer" suffix will be used.             
             /// </summary>
             public string? {{PROPERTY_TRANSFORMER_CLASS_NAME}} { get; set; }

             /// <summary>
             /// The namespace to generate the transformer class within. If not provided the namespace of the enum will be used
             /// </summary>
             public string? {{PROPERTY_TRANSFORMER_CLASS_NAMESPACE}} { get; set; }
         }
     }
     """;

    private static Result<TransformerMeta?, Diagnostic> GetTypeToGenerate(GeneratorAttributeSyntaxContext context, CancellationToken ct)
    {
        if (context.TargetSymbol is not INamedTypeSymbol enumSymbol ||
            enumSymbol.TypeKind != TypeKind.Enum ||
            enumSymbol is IErrorTypeSymbol ||
            (enumSymbol.GetAttributes() is var attributes && attributes.Length == 0)
           )
        {
            return (TransformerMeta?)null;
        }

        ct.ThrowIfCancellationRequested();

        string? transformerName = null, transformerNamespace = null;
        bool? caseInsensitive = null, allowParsingNumerics = null;

        bool hasFlags = false;
        var autoAttributeFound = false;

        foreach (var ad in attributes)
        {
            var attrName = ad.AttributeClass?.Name;
            var displayString = ad.AttributeClass?.ToDisplayString();

            if ((attrName == "FlagsAttribute" || attrName == "Flags") &&
                displayString == "System.FlagsAttribute")
            {
                hasFlags = true;
                continue;
            }

            if (attrName != ATTRIBUTE_NAME || displayString != ATTRIBUTE_FULL_NAME)
                continue;

            autoAttributeFound = true;

            foreach (var (key, value) in ad.NamedArguments)
            {
                if (key == PROPERTY_TRANSFORMER_CLASS_NAMESPACE && value.Value?.ToString() is { } ns)
                {
                    transformerNamespace = ns;
                    continue;
                }

                if (key == PROPERTY_TRANSFORMER_CLASS_NAME && value.Value?.ToString() is { } n)
                {
                    transformerName = n;
                    continue;
                }

                if (key == PROPERTY_CASE_INSENSITIVE && value.Value is bool cs)
                {
                    caseInsensitive = cs;
                    continue;
                }

                if (key == PROPERTY_ALLOW_PARSING_NUMERICS && value.Value is bool apn)
                {
                    allowParsingNumerics = apn;
                }
            }
        }

        if (!autoAttributeFound) return (TransformerMeta?)null;

        ct.ThrowIfCancellationRequested();

        string fullyQualifiedName = enumSymbol.ToString();
        string underlyingType = enumSymbol.EnumUnderlyingType?.ToString() ?? "int";

        var memberNames = enumSymbol
            .GetMembers()
            .Where(static member => member.Kind is SymbolKind.Field)
            .Select(static symbol => symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat))
            .ToArray();

        var meta = new TransformerMeta(
            transformerName ?? $"{enumSymbol.Name}Transformer",
            transformerNamespace ?? (enumSymbol.ContainingNamespace.IsGlobalNamespace ? string.Empty : enumSymbol.ContainingNamespace.ToString()),
            caseInsensitive ?? true, allowParsingNumerics ?? true,

            fullyQualifiedName, memberNames,
            enumSymbol.DeclaredAccessibility == Accessibility.Public,
            hasFlags, underlyingType);

        if (meta.CaseInsensitive &&
            memberNames.Length != new HashSet<string>(memberNames, StringComparer.OrdinalIgnoreCase).Count)
        {
            return CreateDiagnostics(CaseInsensitiveIncompatibleMemberNames, enumSymbol);
        }
        else
            return meta;

        static Diagnostic CreateDiagnostics(DiagnosticDescriptor rule, ISymbol? symbol) =>
            Diagnostic.Create(rule, symbol?.Locations[0] ?? Location.None, symbol?.ContainingNamespace?.ToString(), symbol?.Name);
    }
}

internal readonly record struct TransformerMeta(
    string TransformerName, string TransformerNamespace,
    bool CaseInsensitive, bool AllowParsingNumerics,

    string EnumFullyQualifiedName, IReadOnlyList<string> MemberNames,
    bool IsPublic, bool IsFlagEnum, string UnderlyingType);

file static class CurrentExtensions
{
    internal static void Deconstruct<TKey, TValue>(this KeyValuePair<TKey, TValue> pair, out TKey key, out TValue value)
    {
        key = pair.Key;
        value = pair.Value;
    }
}